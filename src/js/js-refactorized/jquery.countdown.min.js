import $ from 'jquery'

class Countdown {
  constructor(element, finalDate, options = {}) {
    this.el = element
    this.$el = $(element)
    this.interval = null
    this.offset = {}
    this.options = $.extend({}, Countdown.defaultOptions, options) // Combina las opciones predeterminadas con las opciones pasadas
    this.instanceNumber = Countdown.instances.length
    Countdown.instances.push(this)
    this.$el.data('countdown-instance', this.instanceNumber)

    if (typeof options === 'function') {
      this.$el.on('update.countdown', options)
      this.$el.on('stopped.countdown', options)
      this.$el.on('finish.countdown', options)
    }

    this.setFinalDate(finalDate)

    if (this.options.defer === false) {
      this.start()
    }
  }

  static instances = []

  static defaultOptions = {
    precision: 100,
    elapse: false,
    defer: false
  }

  start() {
    if (this.interval !== null) {
      clearInterval(this.interval)
    }

    this.update()

    this.interval = setInterval(() => {
      this.update()
    }, this.options.precision)
  }

  stop() {
    clearInterval(this.interval)
    this.interval = null
    this.dispatchEvent('stopped')
  }

  toggle() {
    if (this.interval) {
      this.stop()
    } else {
      this.start()
    }
  }

  pause() {
    this.stop()
  }

  resume() {
    this.start()
  }

  remove() {
    this.stop()
    Countdown.instances[this.instanceNumber] = null
    delete this.$el.data().countdownInstance
  }

  setFinalDate(finalDate) {
    this.finalDate = Countdown.castDate(finalDate)
  }

  update() {
    if (this.$el.closest('html').length === 0) {
      return this.remove()
    }

    const now = new Date()
    let remainingSeconds = Math.ceil((this.finalDate.getTime() - now.getTime()) / 1000)
    remainingSeconds = !this.options.elapse && remainingSeconds < 0 ? 0 : Math.abs(remainingSeconds)

    if (this.totalSecsLeft !== remainingSeconds) {
      this.totalSecsLeft = remainingSeconds
      this.elapsed = now >= this.finalDate
      this.offset = this.calculateOffsets(remainingSeconds)

      this.dispatchEvent('update')

      if (this.totalSecsLeft === 0) {
        this.stop()
        this.dispatchEvent('finish')
      }
    }
  }

  calculateOffsets(totalSecsLeft) {
    return {
      seconds: totalSecsLeft % 60,
      minutes: Math.floor(totalSecsLeft / 60) % 60,
      hours: Math.floor(totalSecsLeft / 60 / 60) % 24,
      days: Math.floor(totalSecsLeft / 60 / 60 / 24) % 7,
      weeks: Math.floor(totalSecsLeft / 60 / 60 / 24 / 7),
      months: Math.floor(totalSecsLeft / 60 / 60 / 24 / 30.4368),
      years: this.finalDate.getFullYear() - new Date().getFullYear(),
      totalDays: Math.floor(totalSecsLeft / 60 / 60 / 24),
      totalHours: Math.floor(totalSecsLeft / 60 / 60),
      totalMinutes: Math.floor(totalSecsLeft / 60),
      totalSeconds: totalSecsLeft
    }
  }

  dispatchEvent(eventType) {
    const event = $.Event(`${eventType}.countdown`)
    event.finalDate = this.finalDate
    event.elapsed = this.elapsed
    event.offset = $.extend({}, this.offset)
    event.strftime = Countdown.formatStrftime(this.offset)
    this.$el.trigger(event)
  }

  static castDate(input) {
    const validDateRegex = new RegExp(
      [
        /^[0-9]*$/.source,
        /([0-9]{1,2}\/){2}[0-9]{4}( [0-9]{1,2}(:[0-9]{2}){2})?/.source,
        /[0-9]{4}([/-][0-9]{1,2}){2}( [0-9]{1,2}(:[0-9]{2}){2})?/.source
      ].join('|')
    )

    if (input instanceof Date) return input

    // Check for valid date format
    if (String(input).match(validDateRegex)) {
      if (String(input).match(/^[0-9]*$/)) {
        input = Number(input)
      }
      // Replace "-" with "/" for compatibility if necessary
      if (String(input).match(/-/)) {
        input = String(input).replace(/-/g, '/')
      }

      // Create a Date object from the input
      const date = new Date(input)

      // Validate the date object
      if (isNaN(date.getTime())) {
        throw new Error(`Couldn't cast \`${input}\` to a date object.`)
      }

      return date
    }

    throw new Error(`Couldn't cast \`${input}\` to a date object.`)
  }

  static formatStrftime(offset) {
    return function(str) {
      const matches = str.match(/%(-|!)?[A-Z]{1}(:[^;]+;)?/gi)
      if (matches) {
        for (let i = 0; i < matches.length; ++i) {
          let match = matches[i].match(/%(-|!)?([a-zA-Z]{1})(:[^;]+;)?/)
          const regex = Countdown.escapeRegex(match[0])
          const modifier = match[1] || ''
          const format = match[3] || ''
          let value = null

          match = match[2]
          if (Object.prototype.hasOwnProperty.call(Countdown.offsetMap, match)) {
            value = offset[Countdown.offsetMap[match]]
            value = Number(value)
          }

          if (value !== null) {
            if (modifier === '!') value = Countdown.pluralize(format, value)
            if (modifier === '' && value < 10) value = '0' + value.toString()
            str = str.replace(regex, value.toString())
          }
        }
      }
      return str.replace(/%%/, '%')
    }
  }

  static escapeRegex(str) {
    return str.toString().replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1')
  }

  static pluralize(format, value) {
    let singular = 's'
    let plural = ''
    if (format) {
      format = format.replace(/(:|;|\s)/gi, '').split(/,/)
      if (format.length === 1) {
        singular = format[0]
      } else {
        plural = format[0]
        singular = format[1]
      }
    }
    return Math.abs(value) > 1 ? singular : plural
  }
}

$.fn.countdown = function() {
  const args = Array.prototype.slice.call(arguments, 0)
  return this.each(function() {
    const instance = $(this).data('countdown-instance')
    if (instance !== undefined) {
      const countdownInstance = Countdown.instances[instance]
      const method = args[0]
      if (Object.prototype.hasOwnProperty.call(Countdown.prototype, method)) {
        countdownInstance[method].apply(countdownInstance, args.slice(1))
      } else if (String(method).match(/^[$A-Z_][0-9A-Z_$]*$/i) === null) {
        countdownInstance.setFinalDate(countdownInstance, method)
        countdownInstance.start()
      } else {
        $.error(`Method ${method} does not exist on jQuery.countdown`)
      }
    } else {
      // Create the Countdown instance and store it in a variable
      const countdownInstance = new Countdown(this, args[0], args[1])
      $(this).data('countdown-instance', countdownInstance.instanceId) // Assuming instanceId is assigned in the Countdown constructor
    }
  })
}

export default Countdown